package main

import (
	"context"
	"flag"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/ethclient"
	oksdk "github.com/okex/exchain-go-sdk"
	"github.com/oklog/run"
	poly_bridge_sdk "github.com/polynetwork/poly-bridge/bridgesdk"
	sdk "github.com/polynetwork/poly-go-sdk"
	"github.com/zhiqiangxu/relay-patch/config"
	"github.com/zhiqiangxu/relay-patch/pkg/log"
	"github.com/zhiqiangxu/relay-patch/pkg/relay"
	"github.com/zhiqiangxu/relay-patch/pkg/storage"
	"github.com/zhiqiangxu/relay-patch/pkg/tools"
	txPkg "github.com/zhiqiangxu/relay-patch/pkg/tx"
)

var confFile string
var tx string
var chain uint64
var force bool
var price string
var print bool
var mr bool

func init() {
	flag.StringVar(&confFile, "conf", "./config.json", "configuration file path")
	flag.StringVar(&tx, "tx", "", "specify tx hash")
	flag.Uint64Var(&chain, "chain", 0, "specify chain ID")
	flag.BoolVar(&force, "force", false, "force transaction")
	flag.StringVar(&price, "price", "", "gas price")
	flag.BoolVar(&print, "print", false, "print merkle value")
	flag.BoolVar(&mr, "mr", false, "check merkle root")

	flag.Parse()
}

func setUpEthClientAndKeyStore(ethConfig *config.EthConfig) (clients []*ethclient.Client, tmClients []*oksdk.Client, ks *tools.EthKeyStore) {

	for _, node := range ethConfig.RestURL {
		client, err := ethclient.Dial(node)
		if err != nil {
			log.Fatalf("ethclient.Dial failed:%v", err)
		}

		clients = append(clients, client)
	}
	for _, tmNode := range ethConfig.TMRestURL {
		config, _ := oksdk.NewClientConfig(tmNode, "okexchain-65", oksdk.BroadcastBlock, "0.01okt", 200000, 0, "")
		client := oksdk.NewClient(config)

		tmClients = append(tmClients, &client)
	}

	start := time.Now()
	chainID, err := clients[0].ChainID(context.Background())
	if err != nil {
		log.Fatalf("clients[0].ChainID failed:%v", err)
	}
	log.Infof("SideChain %d ChainID() took %v", ethConfig.SideChainId, time.Now().Sub(start).String())

	ks = tools.NewEthKeyStore(ethConfig.KeyStorePath, ethConfig.KeyStorePwdSet, chainID)

	return
}

func setUpEthToPoly(ethToPolyCh chan string, polySdk *sdk.PolySdk,
	signer *sdk.Account,
	clients []*ethclient.Client,
	tmClients []*oksdk.Client,
	ethConfig *config.EthConfig,
	conf *config.Config) []*relay.EthToPoly {

	var workers []*relay.EthToPoly
	for i := 0; i < 5; i++ {
		workers = append(workers, relay.NewEthToPoly(ethToPolyCh, polySdk, signer, clients, tmClients, ethConfig, conf))
	}

	return workers
}

func setUpPolyToEth(clients []*ethclient.Client, ks *tools.EthKeyStore, polyToEthWorkCh chan string, polySdk *sdk.PolySdk, bridgeSdk *poly_bridge_sdk.BridgeSdk, ethConfig *config.EthConfig, polyConfig *config.PolyConfig, conf *config.Config) []*relay.PolyToEth {

	var workers []*relay.PolyToEth
	for _, account := range ks.GetAccounts() {
		worker := relay.NewPolyToEth(polyToEthWorkCh, polySdk, bridgeSdk, clients, ethConfig, polyConfig, conf, account, ks)
		workers = append(workers, worker)
	}

	return workers
}

func idToEthConf(id uint64, conf *config.Config) *config.EthConfig {
	if id == 0 {
		return nil
	}
	switch id {
	case conf.BSCConfig.SideChainId:
		return &conf.BSCConfig
	case conf.HecoConfig.SideChainId:
		return &conf.HecoConfig
	case conf.CurveConfig.SideChainId:
		return &conf.CurveConfig
	case conf.EthConfig.SideChainId:
		return &conf.EthConfig
	case conf.OKConfig.SideChainId:
		return &conf.OKConfig
	case conf.BorConfig.SideChainId:
		return &conf.BorConfig
	case conf.ArbConfig.SideChainId:
		return &conf.ArbConfig
	default:
		panic(fmt.Sprintf("unkown chain id:%d", id))
	}
}

func main() {

	log.InitLog(log.InfoLog, "./Log/", log.Stdout)

	conf, err := config.LoadConfig(confFile)
	if err != nil {
		log.Fatalf("LoadConfig fail:%v", err)
	}

	if force {
		conf.Force = true
	}
	if print {
		conf.Print = true
	}
	if mr {
		conf.CheckMerkleRoot = true
	}

	if price != "" {
		gasPrice := big.NewInt(0)
		gasPrice, ok := gasPrice.SetString(price, 10)
		if !ok {
			log.Fatalf("invalid gas price:%v", price)
		}
		conf.GasPrice = gasPrice
	}

	// {
	// 	confBytes, _ := json.MarshalIndent(conf, "", "    ")
	// 	fmt.Println("conf", string(confBytes))
	// }

	polySdk := sdk.NewPolySdk()
	err = setUpPoly(polySdk, conf.PolyConfig.RestURL)
	if err != nil {
		log.Fatalf("setUpPoly failed: %v", err)
	}

	wallet, err := polySdk.OpenWallet(conf.PolyConfig.WalletFile)
	if err != nil {
		log.Fatalf("polySdk.OpenWallet failed: %v", err)
	}
	signer, err := wallet.GetDefaultAccount([]byte(conf.PolyConfig.WalletPwd))
	if err != nil {
		log.Fatalf("wallet.GetDefaultAccount failed: %v", err)
	}

	chainIDs := []uint64{
		conf.BSCConfig.SideChainId,
		conf.HecoConfig.SideChainId,
		conf.CurveConfig.SideChainId,
		conf.EthConfig.SideChainId,
		conf.OKConfig.SideChainId,
		conf.BorConfig.SideChainId,
		conf.ArbConfig.SideChainId,
	}

	ethToPolyChs := make(map[uint64]chan string)
	polyToEthChs := make(map[uint64]chan string)
	eth2PolyWorkers := make(map[uint64][]*relay.EthToPoly)
	polyToEthWorkers := make(map[uint64][]*relay.PolyToEth)
	bridgeSdk := poly_bridge_sdk.NewBridgeSdk(conf.BridgeConfig.RestURL[0][0])
	for _, chainID := range chainIDs {
		polyToEthChs[chainID] = make(chan string)
		ethConf := idToEthConf(chainID, conf)
		if ethConf == nil {
			continue
		}
		if !ethConf.OnlyDst {
			ethToPolyChs[chainID] = make(chan string)
		}
		clients, tmClients, ks := setUpEthClientAndKeyStore(ethConf)

		if ethToPolyChs[chainID] != nil {
			eth2PolyWorkers[chainID] = setUpEthToPoly(ethToPolyChs[chainID], polySdk, signer, clients, tmClients, ethConf, conf)
		}

		polyToEthWorkers[chainID] = setUpPolyToEth(clients, ks, polyToEthChs[chainID], polySdk, bridgeSdk, ethConf, &conf.PolyConfig, conf)
	}

	if tx != "" {
		txes := strings.Split(tx, ",")
		for _, txHash := range txes {
			var (
				targetWorkersForEthToPoly []*relay.EthToPoly
				targetWorkersForPolyToEth []*relay.PolyToEth
				toChainID                 uint64
				polyTxHash                string
			)
			switch chain {
			case 0:
				// handle poly tx hash
				merkleValue, _, _ := relay.GetKeyParams(polySdk, &conf.PolyConfig, txHash, 0)
				if merkleValue == nil {
					log.Errorf("merkle value empty for poly hash %s", tx)
				}
				toChainID = merkleValue.MakeTxParam.ToChainID
				polyTxHash = txHash
				goto HANDLE_POLY_TX
			default:
				targetWorkersForEthToPoly = eth2PolyWorkers[chain]
				if len(targetWorkersForEthToPoly) == 0 {
					log.Fatalf("eth2poly unsupported chainID:%d", chain)
				}

			}

			toChainID, polyTxHash = targetWorkersForEthToPoly[0].MonitorTx(txHash)

			if polyTxHash == "" {
				return
			}

		HANDLE_POLY_TX:

			log.Infof("toChainID:%d poly hash:%s", toChainID, polyTxHash)

			polyTxHeight, err := polySdk.GetBlockHeightByTxHash(polyTxHash)
			if err != nil {
				log.Warnf("polySdk.GetBlockHeightByTxHash failed:%v", err)
				polyTxHeight, err = polySdk.GetCurrentBlockHeight()
				if err != nil {
					log.Fatalf("poly2eth calc polyTxHeight by GetCurrentBlockHeight failed:%v", err)
				}
			}

			waitPolyHeight(polySdk, polyTxHeight+1)

			targetWorkersForPolyToEth = polyToEthWorkers[toChainID]
			if len(targetWorkersForPolyToEth) == 0 {
				log.Fatalf("poly2eth unsupported chainID:%d", toChainID)
			}

			targetWorkersForPolyToEth[0].SendTx(polyTxHash)
		}

		return

	}

	go func() {
		timer := time.NewTimer(time.Minute * 15)
		<-timer.C
		log.Fatal("max time exceeded, auto restart")
	}()

	mysql, err := storage.NewMySQL(conf.MySQLConfig)
	if err != nil {
		log.Fatalf("storage.NewMySQL failed:%v", err)
	}

	filter := txPkg.NewFilter(mysql, ethToPolyChs, polyToEthChs, conf)

	var g run.Group

	g.Add(func() error {
		filter.Start()
		return nil
	}, func(error) {
		filter.Stop()
	})

	var toPolyWorkers []*relay.EthToPoly
	for _, worker := range eth2PolyWorkers {
		toPolyWorkers = append(toPolyWorkers, worker...)
	}
	for i := range toPolyWorkers {
		worker := toPolyWorkers[i]
		g.Add(func() error {
			worker.Start()
			return nil
		}, func(error) {
			worker.Stop()
		})
	}
	var fromPolyWorkers []*relay.PolyToEth
	for _, worker := range polyToEthWorkers {
		fromPolyWorkers = append(fromPolyWorkers, worker...)
	}
	for i := range fromPolyWorkers {
		worker := fromPolyWorkers[i]
		g.Add(func() error {
			worker.Start()
			return nil
		}, func(error) {
			worker.Stop()
		})
	}

	go func() {
		err := g.Run()
		log.Fatalf("run.Group finished:%v", err)
		for _, workCh := range ethToPolyChs {
			close(workCh)
		}
		for _, workCh := range polyToEthChs {
			close(workCh)
		}
	}()

	for _, workCh := range ethToPolyChs {
		<-workCh
	}
	for _, workCh := range polyToEthChs {
		<-workCh
	}
	return
}

func setUpPoly(polySdk *sdk.PolySdk, rpcAddr string) error {
	polySdk.NewRpcClient().SetAddress(rpcAddr)
	hdr, err := polySdk.GetHeaderByHeight(0)
	if err != nil {
		return err
	}
	polySdk.SetChainId(hdr.ChainID)
	return nil
}

func waitPolyHeight(polySdk *sdk.PolySdk, height uint32) {
	for {
		currentHeight, err := polySdk.GetCurrentBlockHeight()
		if err != nil {
			log.Fatalf("polySdk.GetCurrentBlockHeight failed:%v", err)
		}
		if currentHeight >= height {
			break
		}
		log.Infof("wait poly height:%d, current height:%d", height, currentHeight)
		time.Sleep(time.Second)
	}

}
